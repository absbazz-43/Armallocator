show("main_ui")
shinyalert("Welcome!", paste("Authenticated as:", email), type = "success")
} else {
# Not a Pathao email
shinyalert("Access Denied",
paste("Only @pathao.com emails are allowed.\n",
"Please use your Pathao email address."),
type = "error")
}
} else {
shinyalert("Error", "Please enter your @pathao.com email address.", type = "error")
}
})
# Google authentication button handler
observeEvent(input$auth_btn, {
showModal(modalDialog(
title = "Google Authentication",
tags$div(
if (is_posit_connect()) {
tags$p("On Posit Connect, please use the manual email input below for authentication.")
} else {
tagList(
tags$p("Please sign in with your Pathao Google account (@pathao.com)"),
tags$p("1. A browser window will open for Google authentication"),
tags$p("2. Sign in with your @pathao.com account"),
tags$p("3. Grant BigQuery access permissions"),
tags$p("4. Return to this window")
)
}
),
footer = modalButton("Close"),
easyClose = FALSE
))
if (is_posit_connect()) {
# On Posit Connect, suggest using manual authentication
removeModal()
shinyalert("Info",
"For Posit Connect deployment, please use the manual email input below the Google sign-in button.",
type = "info")
return()
}
tryCatch({
# Local development - use Google auth
success <- authenticate_google()
if (success) {
email <- get_user_email()
if (!is.null(email) && verify_pathao_email(email)) {
# Success
removeModal()
is_authenticated(TRUE)
user_email(email)
hide("auth_ui")
show("main_ui")
shinyalert("Welcome!", paste("Authenticated as:", email), type = "success")
} else {
removeModal()
shinyalert("Authentication Error",
"Could not verify Pathao email. Please try again.",
type = "error")
}
} else {
removeModal()
shinyalert("Authentication Failed",
"Google authentication failed. Please try again or use manual email input.",
type = "error")
}
}, error = function(e) {
removeModal()
shinyalert("Authentication Failed",
paste("Error:", e$message),
type = "error")
})
})
# Display user email in the app
output$user_info <- renderUI({
req(user_email())
tags$div(
style = "position: absolute; top: 10px; right: 10px; background: #f8f9fa; padding: 8px 15px; border-radius: 20px; border: 1px solid #ddd;",
tags$span(icon("user"), "Logged in as: ", tags$strong(user_email()))
)
})
# Add user info to main UI
insertUI(
selector = "#main_ui",
where = "afterBegin",
ui = uiOutput("user_info")
)
# For Posit Connect, we need to handle BigQuery authentication differently
# Use service account or other authentication methods
# YOUR EXISTING SERVER CODE STARTS HERE
# Reactive values
query_results <- reactiveVal(NULL)
randomized_data <- reactiveVal(NULL)
# Modified data_loader function for Posit Connect
data_loader <- function(project_id, query) {
if (is_posit_connect()) {
# On Posit Connect, you'll need to use service account authentication
# This requires setting up a service account JSON key
shinyalert("Info", "BigQuery access on Posit Connect requires service account setup. Please contact administrator.", type = "info")
return(data.frame())  # Return empty dataframe
} else {
# Local development - use normal authentication
bq_auth()
job <- bq_project_query(project_id, query)
results <- bq_table_download(job)
return(results)
}
}
# SQL Runner Tab
observeEvent(input$run_query, {
req(input$project_id, input$sql_query)
if (!nzchar(input$sql_query)) {
showNotification("Please enter a SQL query", type = "warning")
return()
}
sql_query <- input$sql_query
if (input$limit_rows > 0 && !grepl("\\bLIMIT\\s+\\d+\\s*$", sql_query, ignore.case = TRUE)) {
sql_query <- paste(sql_query, "LIMIT", input$limit_rows)
}
showNotification("Running query...", type = "message", duration = NULL)
tryCatch({
results <- data_loader(input$project_id, sql_query)
query_results(results)
removeNotification("running")
showNotification(sprintf("Query completed. %d rows returned.", nrow(results)),
type = "message", duration = 3)
}, error = function(e) {
removeNotification("running")
showNotification(sprintf("Error: %s", e$message), type = "error")
query_results(NULL)
})
})
# ... [KEEP THE REST OF YOUR EXISTING SERVER CODE] ...
output$results_table <- renderDT({
req(query_results())
datatable(query_results(), options = list(scrollX = TRUE, scrollY = 400))
})
output$query_info <- renderText({
results <- query_results()
if (is.null(results)) return("No query results to display. Run a query to see results here.")
sprintf("Query returned %d rows and %d columns. Memory usage: %s",
nrow(results), ncol(results),
format(object.size(results), units = "MB"))
})
# Randomizer Tab
output$arm_proportion_ui <- renderUI({
arm_no <- input$arm_no
proportions <- rep(1/arm_no, arm_no)
lapply(1:arm_no, function(i) {
numericInput(paste0("arm_prop_", i), paste0("Arm ", i, " Proportion:"),
value = proportions[i], min = 0, max = 1, step = 0.1)
})
})
output$arm_name_ui <- renderUI({
arm_no <- input$arm_no
lapply(1:arm_no, function(i) {
textInput(paste0("arm_name_", i), paste0("Arm ", i, " Name:"), value = paste0("arm_", i))
})
})
output$confounders_ui <- renderUI({
req(query_results())
data <- query_results()
numeric_cols <- names(data)[sapply(data, is.numeric)]
selectInput("confounders", "Confounders (numeric columns):",
choices = numeric_cols, multiple = TRUE)
})
observeEvent(input$run_randomizer, {
req(query_results(), input$arm_no)
# Collect arm proportions and names
arm_proportion <- sapply(1:input$arm_no, function(i) {
input[[paste0("arm_prop_", i)]]
})
arm_name <- sapply(1:input$arm_no, function(i) {
input[[paste0("arm_name_", i)]]
})
if (sum(arm_proportion) != 1) {
showNotification("Arm proportions must sum to 1!", type = "error")
return()
}
tryCatch({
randomized <- data_maker(
experiment_data = query_results(),
arm_proportion = arm_proportion,
arm_no = input$arm_no,
arm_name = arm_name,
experiment_name = input$experiment_name,
use_smd = input$use_smd,
confounders = input$confounders,
smd_threshold = input$smd_threshold
)
randomized_data(randomized)
showNotification("Randomization completed successfully!", type = "message")
}, error = function(e) {
showNotification(paste("Randomization error:", e$message), type = "error")
})
})
output$randomized_table <- renderDT({
req(randomized_data())
datatable(randomized_data(), options = list(scrollX = TRUE, scrollY = 400))
})
# Balance Checker Tab
output$confounders_balance_ui <- renderUI({
req(randomized_data())
data <- randomized_data()
numeric_cols <- names(data)[sapply(data, is.numeric)]
selectInput("confounders_balance", "Confounders for Balance Check:",
choices = numeric_cols, multiple = TRUE)
})
observe({
req(randomized_data())
data <- randomized_data()
updateSelectInput(session, "treatment_var",
choices = names(data)[sapply(data, function(x) is.character(x) | is.factor(x))])
})
observeEvent(input$run_balance_check, {
req(randomized_data(), input$treatment_var, input$confounders_balance)
tryCatch({
# SMD Check
balance_result <- smd_checker(
experiment_data = randomized_data(),
treatment = input$treatment_var,
confounders = input$confounders_balance
)
# SRM Check
treatment_counts <- table(randomized_data()[[input$treatment_var]])
expected_props <- prop.table(treatment_counts)
srm_result <- check_srm(
experiment_df = randomized_data(),
allocated_arm_col = input$treatment_var,
expected_proportions = expected_props
)
output$love_plot <- renderPlot({
balance_result$love_plot
})
output$srm_result <- renderText({
srm_result
})
output$balance_table <- renderPrint({
balance_result$balance_tab
})
}, error = function(e) {
showNotification(paste("Balance check error:", e$message), type = "error")
})
})
# Distribution Checker Tab
observe({
req(randomized_data())
data <- randomized_data()
# Update treatment variable choices
updateSelectInput(session, "dist_treatment_var",
choices = names(data)[sapply(data, function(x) is.character(x) | is.factor(x))])
# Update target variable choices
updateSelectInput(session, "dist_target_var",
choices = names(data))
})
# Variable information
output$var_info <- renderText({
req(randomized_data(), input$dist_target_var)
data <- randomized_data()
var <- data[[input$dist_target_var]]
info <- paste(
"Variable:", input$dist_target_var, "\n",
"Type:", class(var), "\n",
"Missing values:", sum(is.na(var)), "\n",
"Unique values:", length(unique(var)), "\n"
)
if (is.numeric(var)) {
info <- paste0(info,
"Range: [", min(var, na.rm = TRUE), ", ", max(var, na.rm = TRUE), "]\n",
"Mean: ", round(mean(var, na.rm = TRUE), 2), "\n",
"SD: ", round(sd(var, na.rm = TRUE), 2)
)
} else if (is.character(var) || is.factor(var)) {
top_categories <- names(sort(table(var), decreasing = TRUE))[1:3]
info <- paste0(info,
"Top categories: ", paste(top_categories, collapse = ", ")
)
}
return(info)
})
observeEvent(input$run_dist_check, {
req(randomized_data(), input$dist_treatment_var, input$dist_target_var)
tryCatch({
data <- randomized_data()
target_var <- data[[input$dist_target_var]]
# Auto-detect plot type if not specified
plot_type <- input$plot_type
if (is.null(plot_type)) {
plot_type <- ifelse(is.numeric(target_var), "density", "bar")
}
if (plot_type == "density" && !is.numeric(target_var)) {
showNotification("Density plots require numeric variables. Switching to bar chart.",
type = "warning")
plot_type <- "bar"
updateRadioButtons(session, "plot_type", selected = "bar")
}
if (plot_type == "bar" && is.numeric(target_var)) {
# For numeric variables in bar charts, we can bin them
data <- data %>%
mutate(!!input$dist_target_var := cut(!!rlang::parse_expr(input$dist_target_var),
breaks = 10, include.lowest = TRUE))
}
if (plot_type == "density") {
output$density_plot <- renderPlot({
density_checker(data, input$dist_treatment_var, input$dist_target_var)
})
} else {
output$bar_plot <- renderPlot({
bar_chart_checker(data, input$dist_treatment_var, input$dist_target_var)
})
}
# Summary statistics
output$summary_stats <- renderPrint({
cat("Summary for:", input$dist_target_var, "\n")
cat("By treatment group:", input$dist_treatment_var, "\n\n")
if (is.numeric(target_var)) {
summary_df <- data %>%
group_by(!!rlang::parse_expr(input$dist_treatment_var)) %>%
summarise(
N = n(),
Mean = mean(!!rlang::parse_expr(input$dist_target_var), na.rm = TRUE),
SD = sd(!!rlang::parse_expr(input$dist_target_var), na.rm = TRUE),
Min = min(!!rlang::parse_expr(input$dist_target_var), na.rm = TRUE),
Max = max(!!rlang::parse_expr(input$dist_target_var), na.rm = TRUE)
)
print(summary_df, n = Inf)
} else {
summary_df <- data %>%
group_by(!!rlang::parse_expr(input$dist_treatment_var),
!!rlang::parse_expr(input$dist_target_var)) %>%
summarise(Count = n(), .groups = "drop") %>%
group_by(!!rlang::parse_expr(input$dist_treatment_var)) %>%
mutate(Percentage = round(Count / sum(Count) * 100, 1))
print(summary_df, n = Inf)
}
})
}, error = function(e) {
showNotification(paste("Distribution check error:", e$message), type = "error")
})
})
# Auto-update plot type based on variable type
observe({
req(randomized_data(), input$dist_target_var)
data <- randomized_data()
var <- data[[input$dist_target_var]]
if (is.numeric(var)) {
updateRadioButtons(session, "plot_type", selected = "density")
} else if (is.character(var) || is.factor(var)) {
updateRadioButtons(session, "plot_type", selected = "bar")
}
})
observe({
req(randomized_data())
data <- randomized_data()
updateSelectInput(session, "ab_treatment_var",
choices = names(data)[sapply(data, function(x) is.character(x) | is.factor(x))])
updateSelectInput(session, "ab_metric_var",
choices = names(data)[sapply(data, is.numeric)])
})
observeEvent(input$run_ab_test, {
req(randomized_data(), input$ab_treatment_var, input$ab_metric_var)
tryCatch({
results <- calculate_ab_test_results(
data = randomized_data(),
treatment_col = input$ab_treatment_var,
metric_col = input$ab_metric_var,
control_group = input$control_group,
test_type = input$test_type,
confidence_level = input$confidence_level
)
# Summary table
output$ab_summary_table <- renderTable({
results$summary
}, digits = 3)
# Individual result outputs
output$effect_size_output <- renderText({
sprintf("%.3f", results$effect_size)
})
output$cle_output <- renderText({
sprintf("%.1f%%", results$common_language_es * 100)
})
output$power_output <- renderText({
sprintf("%.1f%%", results$power * 100)
})
output$difference_output <- renderText({
sprintf("%.3f", results$difference)
})
output$relative_effect_output <- renderText({
sprintf("%.1f%%", results$relative_effect * 100)
})
output$ci_output <- renderText({
sprintf("[%.3f, %.3f]", results$confidence_interval[1], results$confidence_interval[2])
})
# Hypothesis test result
output$test_result_output <- renderUI({
p_value <- results$test_result$p.value[1]
statistic <- results$test_result$statistic[1]
test_name <- switch(input$test_type,
"t_test" = "t-test",
"z_test" = "z-test",
"wilcoxon" = "Wilcoxon rank-sum test",
"bootstrap" = "Bootstrap (with t-test p-value)")
significance <- ifelse(p_value < 0.05, "significant", "not significant")
significance_class <- ifelse(p_value < 0.05, "significant", "not-significant")
tagList(
p(strong("Test:"), test_name),
p(strong("Statistic:"), sprintf("%.3f", statistic)),
p(strong("P-value:"), sprintf("%.4f", p_value)),
p(strong("Conclusion:"),
span(significance, class = significance_class))
)
})
}, error = function(e) {
showNotification(paste("A/B Test error:", e$message), type = "error")
})
})
# Trend Analysis Tab
observe({
req(randomized_data())
data <- randomized_data()
updateSelectInput(session, "trend_treatment_var",
choices = names(data)[sapply(data, function(x) is.character(x) | is.factor(x))])
updateSelectInput(session, "trend_metric_var",
choices = names(data)[sapply(data, is.numeric)])
# Find date columns
date_cols <- names(data)[sapply(data, function(x) inherits(x, "Date") |
inherits(x, "POSIXt"))]
updateSelectInput(session, "date_var", choices = date_cols)
})
observeEvent(input$run_trend_analysis, {
req(randomized_data(), input$trend_treatment_var, input$trend_metric_var, input$date_var)
tryCatch({
output$trend_plot <- renderPlot({
create_trend_plot(
data = randomized_data(),
treatment_col = input$trend_treatment_var,
metric_col = input$trend_metric_var,
date_col = input$date_var,
control_group = input$trend_control_group
)
})
# Trend summary table
output$trend_summary_table <- renderTable({
randomized_data() %>%
group_by(!!rlang::parse_expr(input$trend_treatment_var)) %>%
summarise(
Mean = mean(!!rlang::parse_expr(input$trend_metric_var), na.rm = TRUE),
SD = sd(!!rlang::parse_expr(input$trend_metric_var), na.rm = TRUE),
N = n(),
.groups = "drop"
)
}, digits = 3)
}, error = function(e) {
showNotification(paste("Trend analysis error:", e$message), type = "error")
})
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('app2.R')
runApp('app2.R')
runApp('app2.R')
library(bigrquery)
data_loader <- function(project_id, query, email = NULL) {
# Authenticate with optional email
if (!is.null(email)) {
bq_auth(email = email)
} else {
bq_auth()
}
# Run query
job <- bq_project_query(project_id, query)
# Download results
results <- bq_table_download(job)
return(results)
}
df <- data_loader(
project_id = "data-eng-platform",
query = "SELECT * FROM data-eng-platform.base_courier.hermes_hubs",
email = "bishal.sarker@pathao.com"
)
df <- data_loader(
project_id = "data-eng-platform",
query = "SELECT * FROM data-eng-platform.base_courier.hermes_hubs",
email = "sarkerbishal02@pathao.com"
)
df
df <- data_loader(
project_id = "data-eng-platform",
query = "SELECT * FROM data-eng-platform.base_courier.hermes_hubs",
email = "sarkerbishal02@gamil.com"
)
library(bigrquery)
data_loader <- function(project_id, query, email = NULL) {
# Authenticate with optional email
if (!is.null(email)) {
bq_auth(email = email)
} else {
bq_auth()
}
# Run query
job <- bq_project_query(project_id, query)
# Download results
results <- bq_table_download(job)
return(results)
}
df <- data_loader(
project_id = "data-eng-platform",
query = "SELECT * FROM data-eng-platform.base_courier.hermes_hubs",
email = "sarkerbishal02@gamil.com"
)
df
